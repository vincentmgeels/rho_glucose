---
title: "SRVF"
author: "Vincent Geels"
date: "7/17/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
install.packages("fdasrvf")
install.packages("chron")
install.packages("lubridate")
install.packages("ggplot2")
install.packages("dplyr")
install.packages("zoo")
install.packages("tidyr")
install.packages("hms")
install.packages("fda")
install.packages("dtw")
install.packages("fdakma")
library(fdasrvf)
library(chron)
library(lubridate)
library(ggplot2)
library(dplyr)
library(zoo)
library(tidyr)
library(hms)
library(fda)
library(dtw)
library(fdakma)
```

## Example function alignment using the SRVF framework

```{r alldata3days}
#load in data
ds_cgm_complete_3days <- readRDS("C:/Users/vince/Documents/Life/IMSM/Rho_glucose/data/ds_cgm_complete_3days.RDS")
```

```{r datasub1}
#load in data
#datasub1 <- read.csv("C:/Users/vince/Documents/Life/IMSM/Rho_glucose/data/ds_cgm_sub10.csv",header=TRUE)
ds_cgm_sub1 <- readRDS("C:/Users/vince/Documents/Life/IMSM/Rho_glucose/data/ds_cgm_sub10.RDS")
ds_cgm_sub10 <- readRDS("C:/Users/vince/Documents/Life/IMSM/Rho_glucose/data/ds_cgm_3days_sub10.RDS")
ds_cgm_3days_sub10 <- readRDS("C:/Users/vince/Documents/Life/IMSM/Rho_glucose/data/ds_cgm_3days_sub10.RDS")


#get a time grid for the full 24-hour day in 5-minute increments from midnight to midnight
timegrid <- format( seq.POSIXt(as.POSIXct(Sys.Date()), as.POSIXct(Sys.Date()+1), by = "5 min"),tz="GMT")
timegrid <- timegrid[-289]


#test plot first patient on day 253 from enroll (id=65) to check
pt65.day253 <- subset(ds_cgm_sub10,pt_id %in% 65, select = c(pt_id,visitnum,device_dt_tm_days_from_enroll,device_tm_bin,glucose_value))
pt65.day253 <- subset(pt65.day253,device_dt_tm_days_from_enroll %in% 253, select = c(pt_id,visitnum,device_dt_tm_days_from_enroll,device_tm_bin,glucose_value))

plot(pt65.day253$device_tm_bin,pt65.day253$glucose_value,type="l",xlab="time on day=253 from enroll",ylab="glucose value")


```

```{r alignmentexample}

#get glucose values from first patient on day 255 from enroll (id=65) to check
pt65.day255 <- subset(ds_cgm_sub10,pt_id %in% 65, select = c(pt_id,visitnum,device_dt_tm_days_from_enroll,device_tm_bin,glucose_value))
pt65.day255 <- subset(pt65.day255,device_dt_tm_days_from_enroll %in% 255, select = c(pt_id,visitnum,device_dt_tm_days_from_enroll,device_tm_bin,glucose_value))

#get glucose values from first patient on day 256 from enroll (id=65) to check
pt65.day256 <- subset(ds_cgm_sub10,pt_id %in% 65, select = c(pt_id,visitnum,device_dt_tm_days_from_enroll,device_tm_bin,glucose_value))
pt65.day256 <- subset(pt65.day256,device_dt_tm_days_from_enroll %in% 256, select = c(pt_id,visitnum,device_dt_tm_days_from_enroll,device_tm_bin,glucose_value))

#plotting selected days against one another
#plot(pt65.day254$device_tm_bin,pt65.day254$glucose_value,type="l",xlab="time",ylab="glucose value")
png("ex_pre_alignment")
plot(pt65.day255$device_tm_bin,pt65.day255$glucose_value,type="l",xlab="time (binned in 5-min increments)",ylab="glucose value",ylim=c(min(pt65.day255$glucose_value,pt65.day256$glucose_value),max(pt65.day255$glucose_value,pt65.day256$glucose_value)),col="red")
points(points(pt65.day256$device_tm_bin,pt65.day256$glucose_value,type="l",xlab="time",ylab="glucose value",col="green"))
title(main="pt_id=65, visit 5: days 255-6 prior to alignment")
legend("topright",legend=c("day255","day256"),col=c("red","green"),lty=1:1, cex=0.8)
dev.off()

#align day 256 after enroll curve to day 255 after enroll curve
pt65.day256align = pair_align_functions(pt65.day255$glucose_value,pt65.day256$glucose_value,c(1:length(pt65.day255$glucose_value)),lambda=0,method="DP",w=0.01,iter=2000)

#day 255 vs. day 256 after alignment
png("ex_post_alignment")
plot(pt65.day255$device_tm_bin,pt65.day255$glucose_value,type="l",xlab="time (binned in 5-min increments)",ylab="glucose value",ylim=c(min(pt65.day255$glucose_value,pt65.day256$glucose_value),max(pt65.day255$glucose_value,pt65.day256$glucose_value)),col="red")
points(points(pt65.day256$device_tm_bin,pt65.day256align$f2tilde,type="l",xlab="time",ylab="glucose value",col="green"))
title(main="pt_id=65, visit 5: days 255-6 after alignment")
legend("topright",legend=c("day255","day256"),col=c("red","green"),lty=1:1, cex=0.8)
dev.off()

```


### Algorithm for completing bin time record, imputing missing values, and aligning patient curve data against a baseline patient's visit 0 reference curve:

1. Identify an initial patient via pt_id. WLOG take pt_id = 1 and define pt_id 1 = BASELINE_PATIENT_ID.
2. Extract patient BASELINE_PATIENT_ID's paired glucose/time measurements for visit 0 and day i according to "reasonable" glucose level change patterns (based on visual analysis). WLOG take i = 1.
3. Linearly interpolate missing glucose/time observations on the 288 point grid (corresponding to the number of 5-minute bins per day) for this patient's curve.
4. Set function1 = patient PRIMARY_PATIENT_ID's matrix of paired glucose/time measurements on visit 0, day 1. All other patient paired glucose/time measurements at the day level will now be aligned to function1 in the next step.
5. for (i in (all patient IDs)) do
	set pt_id i = NEW_PT_ID
	for (j in 0:length(visits)) do
		for (k in 1:length(days)) do
			extract patient NEW_PT_ID's paired glucose/time measurements for visit j, day k
			linearly interpolate missing glucose/time observations on the 288 point grid (corresponding to the number of 5-minute bins per day)
			set function2 = patient NEW_PATIENT_ID's matrix of paired glucose/time measurements
			align function2 to function1 via fdasrvf::pair_align_functions

```{r alignalgorithm}
###################################################################################
# first-pass algorithm for adding in rows corresponding to missing device_tm_bins #
###################################################################################

#considering our subsetted data: ds_cgm_sub10.RDS

#get all patient IDs
IDs <- unique(ds_cgm_complete_3days$pt_id,incomparables = FALSE)

#identify baseline patient ID
base_id <- IDs[1]

#get all visit periods
visits <- seq(0,5,1)

#get visit period 0 for our baseline patient
thisvisit <- 0

#define a day-within-visit variable for use later (via day_in_subrange column)
visitdays <- seq(1,3,by=1)

#select the day-level baseline patient curve against which all other day-level patient curves will be aligned to 
visitday <- 2


#extract relevant "baseline" functional data to feed into fdasrvf::pair_align_functions as fixed function1
#returns (# of measurements)x2 tibble
function1 <- ds_cgm_complete_3days %>%
  filter(pt_id == IDs[1], as.character(visitnum) == as.character(thisvisit), day_in_subrange %in% 1:3) %>%
  select(pt_id,trt_group,visitnum,day_in_subrange,glucose_value,device_tm_bin)

#convert tibble to df
f1.df <- as.data.frame(function1) 

#check plot beforehand
f1.df %>%
  ggplot(aes(x = device_tm_bin, y = glucose_value, group = day_in_subrange, color = day_in_subrange)) + 
  geom_line()


######################################################################################################
# APPROACH FOR ADDING MISSING device_tm_bin cells + NAs - THIS IS INEFFICIENT DUE TO REPEATED rbinds #
######################################################################################################

length.IDs <- length(IDs)
length.days <- length(visitdays) #corresponds to number of consecutive days over which patient data was selected
length.obsns <- 288 #the number of measurements we expect to see in a single day, assuming no missing values

#stack all our observations on top of one another
current.df <- f1.df
for (j in visits){
  for (i in 2:length.IDs){
  
  #get function2 from patient with pt_id = IDs[i]
  function2 <- ds_cgm_complete_3days %>%
    filter(pt_id == IDs[i], visitnum == j, day_in_subrange %in% 1:3) %>%
    select(pt_id,trt_group,visitnum,day_in_subrange,glucose_value,device_tm_bin)

  f2.df <- as.data.frame(function2)
  
  current.df <- rbind(current.df,f2.df)
  
  }
  
}



#add in missing values/rows via complete (allows for preservation of trt_group in resulting df)
ex <- ds_cgm_complete_3days %>% 
  select(pt_id,trt_group,visitnum,day_in_subrange,glucose_value,device_tm_bin) %>%
  mutate(pt_id = factor(pt_id,levels=unique(pt_id))) %>% #preserve ordering by patient id
  complete(nesting(pt_id,trt_group,visitnum,day_in_subrange), device_tm_bin = seq(1,288, 1L))

#resort by patient id, then visit number, then day within visit
ex <- ex %>% group_by(pt_id) %>% arrange(pt_id,visitnum,day_in_subrange) %>% ungroup()

#removes benign "Unknown or uninitialised column" warnings
ex <- as.data.frame(ex)

##########################################################################
#save full patient record after adding back in missing values/rows
saveRDS(ex, file = "ds_cgm_complete_3days_with_NAs.RDS")
##########################################################################


#save ex object, now with time record gaps filled in by NA values
saveRDS(ex, file = "ds_cgm_3days_sub10_with_NAs.rds")

#all max device_tm_bin values should equal 288
out <- ex %>%
    group_by(pt_id,day_in_subrange) %>%
    summarize(max.bintm = max(device_tm_bin))

#some plotting
ex %>%
  filter(day_in_subrange == 1) %>%
  ggplot(aes(x = device_tm_bin, y = glucose_value, group =pt_id, color = pt_id)) + 
  geom_line() +
  ggtitle("pt_id = 155, visit 5, day 2: patient curve data before cubic spline interpolation")

#plot to check behavior/see how many NA values there are
ex %>%
  ggplot(aes(x = device_tm_bin, y = glucose_value, group =pt_id, color = pt_id)) + 
  geom_line() +
  ggtitle("pt_id = 155, visit 5, day 2: patient curve data before cubic spline interpolation")
ggsave("curve_data_ex_before_interp.png",device="png")


```

```{r}
#interpolate missing glucose measurement values for each patient's curve data using some kind of method--use zoo::na.approx to do linear interpolation based on issues identified with cubic spline interpolation
#create new column to store imputed values
ex$glucose_imputed <- rep(0,288*length.IDs*length.days)
#update patient ID factor levels
IDs <- levels(ex$pt_id)

#do the linear interpolation and write values to ex$glucose_imputed
increment <- 1
for (i in 1:length.IDs){
  for (j in visits){
    
  #do imputation for patient i on visit j
  temp <- ex %>%
    filter(pt_id == IDs[i], visitnum == j) %>%
    #arrange(pt_id, visitnum, device_tm_bin)
    #na.approx does the linear interpolation; na.rm = FALSE preserves leading or trailing NAs. na.fill's "extend" fills in the leading or trailing NAs with the nearest non-NA value.
    mutate(glucose_imputed = zoo::na.fill(na.approx(glucose_value, na.rm = FALSE),"extend")) %>% #requires zoo package
    select(glucose_imputed)
  first <- 1+(increment-1)*length.obsns*length.days
  last <- increment*length.obsns*length.days
  #write imputed values to ex$glucose_imputed
  ex$glucose_imputed[first:last] <- temp$glucose_imputed

  increment <- increment + 1
    
  }

}
increment <- 1

#save ex object to RDS, now with NA values imputed/extended:
saveRDS(ex, file = "ds_cgm_3days_complete_with_imputed.RDS")

#save ex object to RDS, now with NA values imputed/extended:
saveRDS(ex, file = "ds_cgm_3days_sub10_with_imputed.rds")

################################################
# GRAPHICS FOR SELECTED BASELINE PATIENT CURVE #
################################################

#selected baseline patient curve before linear interpolation
ex %>%
  filter(pt_id == IDs[57], visitnum == 0, day_in_subrange == 1) %>%
  ggplot(aes(x = as.POSIXct(timegrid), y = glucose_value, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("pt_id = 78, 0 days from initial visit: baseline curve for alignment before lin. interpolation") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") + 
  xlab("time of day (hr:min:sec)") +
  ylab("glucose values")
ggsave("./baseline_curve_data_for_alignment_before_interp.png",device="png")

#selected baseline patient curve after linear interpolation
ex %>%
  filter(pt_id == IDs[57], visitnum == 0, day_in_subrange == 1) %>%
  ggplot(aes(x = as.POSIXct(timegrid), y = glucose_imputed, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("pt_id = 78, 0 days from initial visit: baseline curve for alignment after lin. interpolation") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") + 
  xlab("time of day (hr:min:sec)") +
  ylab("glucose values")
ggsave("./baseline_curve_data_for_alignment_after_interp.png",device="png")

#now we have our baseline patient data
baseline_data <- ex %>%
  filter(pt_id == IDs[57], visitnum == 0, day_in_subrange == 1)
#save this to an RDS
saveRDS(baseline_data,file="baseline_patient_data_for_srvf_align.RDS")


#get the imputed values from our baseline reference patient data
f1.imputed <- baseline_data %>%
  select(pt_id,glucose_imputed,device_tm_bin)

#create new column in ex object for storing aligned function values
ex$glucose_aligned <- rep(0,length(ex$pt_id))

#begin alignment of remaining patient curves to baseline patient curve for this visit and day:
incr <- 1
for (j in 1:length.IDs){
  for (i in visits){
    for (k in 1:length.days){
      function2 <- ex %>%
      filter(pt_id == IDs[j], day_in_subrange == k, visitnum == i) %>%
      select(pt_id,glucose_imputed,device_tm_bin)
      #align function2 to function1 via fdasrvf package
      function2_aligned <- fdasrvf::pair_align_functions(f1.imputed$glucose_imputed, function2$glucose_imputed,f1.imputed$device_tm_bin)
      #store function2_aligned data back in ex
      first <- 1+(incr-1)*length.obsns
      last <- incr*length.obsns
      ex$glucose_aligned[first:last] <- function2_aligned$f2tilde
      incr <- incr + 1
    }
  }
}
incr <- 1


ex <-  ex %>% mutate(device_tm_bin_start_tm = 
           hms::as_hms((device_tm_bin * 60 * 5) - (5 * 60)))

#save object for now
saveRDS(ex,file="ds_cgm_complete_3days_after_align.RDS")

#checking the alignment
ex %>%
  filter(pt_id == IDs[57:62],visitnum == 5, day_in_subrange == 3) %>%
  ggplot(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_aligned, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("0 days from initial visit: select curve data after lin. interpolation and srvf alignment") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  xlab("time of day (hr:min:sec)") +
  ylab("glucose values")



###################
#plotting progress#
###################
ex %>%
  filter(pt_id == IDs[57:62],visitnum == 0, day_in_subrange == 1) %>%
  ggplot(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_value, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("0 days from initial visit: select curve data before lin. interpolation and alignment") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  xlab("time of day (hr:min:sec)") +
  ylab("glucose values")
ggsave("04_ex_curves_before_imputation_and_alignment.png",device="png")

ex %>%
  filter(pt_id == IDs[57:62],visitnum == 0, day_in_subrange == 1) %>%
  ggplot(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_imputed, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("0 days from initial visit: select curve data after lin. interpolation, before alignment") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  xlab("time of day (hr:min:sec)") +
  ylab("glucose values")
ggsave("04_ex_curves_after_imputation_before_alignment.png",device="png")

ex %>%
  filter(pt_id == IDs[57:62],visitnum == 0, day_in_subrange == 1) %>%
  ggplot(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_aligned, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("0 days from initial visit: select curve data after lin. interpolation and srvf alignment") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  xlab("time of day (hr:min:sec)") +
  ylab("glucose values")
ggsave("04_ex_curves_after_imputation_and_alignment.png",device="png")



```

```{r subsetting}
#subset patients from visit 5 based on this new dataframe containing aligned values
ds_cgm_3days_sub10_aligned <- ex %>% filter(pt_id %in% as.character(unique(ds_cgm_sub10$pt_id)), visitnum == 5)

#save the object 
saveRDS(ds_cgm_3days_sub10_aligned,file="ds_cgm_3days_sub10_aligned.RDS")

```

```{r dtwalgorithm}

#work with sub10 group and check alignment

#grab a patient
f2.pt3 <- ds_cgm_3days_sub10_aligned %>% filter (pt_id == "40",visitnum == 5, day_in_subrange == 1)

out <- fdasrvf::pair_align_functions(f1.imputed$glucose_imputed,f2.pt3$glucose_imputed,time=seq(1,288,1))

plot(x=as.POSIXct(timegrid),y=f2.pt3$glucose_imputed, xlab="time",ylab="glucose values",main="patient 40, 178 days from initial visit: before and after srvf alignment",type="l")
lines(x=as.POSIXct(timegrid),y=out$f2tilde,col="red",type="l")
legend("topleft", legend = c("before alignment","after alignment"),lty = 1:1, col=c("black","red"))

out <- dtw(f1.imputed$glucose_imputed,f2.pt3$glucose_imputed)

ex %>%  filter(pt_id == IDs[79],visitnum == 2, day_in_subrange == 3) %>%
  ggplot() +
  geom_line(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_imputed), color = "blue") +
  geom_line(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_aligned), color = "red") +
  ggtitle("0 days from initial visit: select curve data after lin. interpolation, before alignment") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  xlab("time of day (hr:min:sec)") +
  ylab("glucose values")

saveRDS(ex,file="")


```






```{r junaplotoutput1}
#playing around with adjusting default plot settings in juna's model
day1_tperm <- readRDS("C:/Users/vince/Documents/R projects/rho_glucose/code/day1_tperm.RDS")

day1_tperm

#want the following in our plot: test statistic curve, pointwise critical values, maximum critical values, legend, x-axis is time, y-axis is t-stat values

#this is a working version in base R plot
plot(x=as.POSIXct(timegrid),y=day1_tperm$Tvals,xlab="time (hr:min:sec)",ylab="t-statistic",type="l",col="red",lwd=2)
lines(x=as.POSIXct(timegrid),y=rep(day1_tperm$qval,length(day1_tperm$Tvals)),type="l",col="blue",lty=2, lwd = 1)
lines(x=as.POSIXct(timegrid),y=day1_tperm$qvals.pts,type="l",col="blue",lty=3,lwd=1)
legend("topright",legend = c("Observed Statistic", paste(0.1," pointwise critical value"), paste(0.1," maximum critical value")),
       col = c("red", "blue", "blue"), lwd = c(2,1,1), lty = c(1,2,2), cex = 0.6)

#trying ggplot
ggplot(aes(x = as.POSIXct(timegrid), y = as.vector(day1_tperm$Tvals), color = "red")) + 
  geom_line()


#max critical value
plot(rep(day1_tperm$qval,length(day1_tperm$Tvals)))

#pointwise critical values
plot(day1_tperm$qvals.pts)

fda.plotter <- function(model.obj,alpha,textsize){
  #requires model.obj be model object from package fda
  #requires ggplot
  #alpha = alpha level
  #textsize is taken as cex argument in legend
  
  #generate the time grid: 24-hour period in 5-minute increments
  timegrid <- hms::as_hms((seq(1,288,1) * 60 * 5) - (5 * 60))

  #build the plot
  plot(x=as.POSIXct(timegrid),y=day1_tperm$Tvals,xlab="time (hr:min:sec)",ylab="t-statistic",type="l",col="red",lwd=2)
  lines(x=as.POSIXct(timegrid),y=rep(day1_tperm$qval,length(day1_tperm$Tvals)),type="l",col="blue",lty=2, lwd = 1)
  lines(x=as.POSIXct(timegrid),y=day1_tperm$qvals.pts,type="l",col="blue",lty=3,lwd=1)
  legend("topright",legend = c("Observed Statistic", paste("pointwise ", alpha, " critical value"), paste("maximum ", alpha, " critical value")),
       col = c("red", "blue", "blue"), lwd = c(2,1,1), lty = c(1,2,3), cex = textsize)

}

fda.plotter(day1_tperm,alpha=0.1,textsize=0.6)

plot(seq(1,288,1),day1_tperm$pvals.pts)

```

## Including Plots

You can also embed plots, for example:




```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
