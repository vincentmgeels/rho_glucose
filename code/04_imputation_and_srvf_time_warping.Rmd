---
title: "MISSING VALUE IMPUTATION AND SRVF ALIGNMENT"
author: "Vincent Geels"
date: "7/17/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
install.packages("fdasrvf")
install.packages("chron")
install.packages("lubridate")
install.packages("ggplot2")
install.packages("dplyr")
install.packages("zoo")
install.packages("tidyr")
install.packages("hms")
install.packages("gridExtra")
library(fdasrvf)
library(chron)
library(lubridate)
library(ggplot2)
library(dplyr)
library(zoo)
library(tidyr)
library(hms)
library(gridExtra)
```

### Algorithm for completing bin time record, imputing missing values, and aligning patient curve data against a baseline patient's visit 0 reference curve:

1. Identify an initial patient via pt_id. WLOG take pt_id = 1 and define pt_id 1 = BASELINE_PATIENT_ID.
2. Extract patient BASELINE_PATIENT_ID's paired glucose/time measurements for visit 0 and day i according to "reasonable" glucose level change patterns (based on visual analysis). WLOG take i = 1.
3. Linearly interpolate missing glucose/time observations on the 288 point grid (corresponding to the number of 5-minute bins per day) for this patient's curve.
4. Set function1 = patient PRIMARY_PATIENT_ID's matrix of paired glucose/time measurements on visit 0, day 1. All other patient paired glucose/time measurements at the day level will now be aligned to function1 in the next step.
5. for (i in (all patient IDs)) do
	set pt_id i = NEW_PT_ID
	for (j in 0:length(visits)) do
		for (k in 1:length(days)) do
			extract patient NEW_PT_ID's paired glucose/time measurements for visit j, day k
			linearly interpolate missing glucose/time observations on the 288 point grid (corresponding to the number of 5-minute bins per day)
			set function2 = patient NEW_PATIENT_ID's matrix of paired glucose/time measurements
			align function2 to function1 via fdasrvf::pair_align_functions

```{r alldata3days}
#load in data
ds_cgm_complete_3days <- readRDS("C:/Users/vince/Documents/Life/IMSM/Rho_glucose/data/ds_cgm_complete_3days.RDS")
```

```{r timegrid}

#get a time grid for the full 24-hour day in 5-minute increments from midnight to midnight; this is for plotting
timegrid <- format( seq.POSIXt(as.POSIXct(Sys.Date()), as.POSIXct(Sys.Date()+1), by = "5 min"),tz="GMT")
timegrid <- timegrid[-289]


```


```{r somesetup}
#############################################################################################
# SOME BREADCRUMBS FOR IDENTIFYING SELECTED BASELINE REFERENCE PATIENT AND ASSOCIATED CURVE #
#############################################################################################

#get all patient IDs from full dataset
IDs <- unique(ds_cgm_complete_3days$pt_id,incomparables = FALSE)

#identify baseline patient ID
base_id <- IDs[57]

#get all visit periods
visits <- seq(0,5,1)

#get visit period 0 for our baseline patient
baselinevisitperiod <- 0

#define a day-within-visit variable for use later (via day_in_subrange column)
visitdays <- seq(1,3,by=1)

#select the day-level baseline patient curve against which all other day-level patient curves will be aligned to 
baselinevisitday <- 1


#extract relevant "baseline" functional data to feed into fdasrvf::pair_align_functions as fixed function1
#returns (# of measurements)x2 tibble
function1 <- ds_cgm_complete_3days %>%
  filter(pt_id == IDs[57], as.character(visitnum) == as.character(thisvisit), day_in_subrange %in% 1:3) %>%
  select(pt_id,trt_group,visitnum,day_in_subrange,glucose_value,device_tm_bin)

#convert tibble to df
f1.df <- as.data.frame(function1) 

#check plot beforehand
f1.df %>%
  ggplot(aes(x = device_tm_bin, y = glucose_value, group = day_in_subrange, color = day_in_subrange)) + 
  geom_line()

```

```{r addingmissingvals}


######################################################################################################
# APPROACH FOR ADDING MISSING device_tm_bin cells + NAs - THIS IS INEFFICIENT DUE TO REPEATED rbinds #
######################################################################################################

length.IDs <- length(IDs)
length.days <- length(visitdays) #corresponds to number of consecutive days over which patient data was selected
length.obsns <- 288 #the number of measurements we expect to see in a single day, assuming no missing values

#stack all our observations on top of one another
current.df <- f1.df
for (j in visits){
  for (i in 2:length.IDs){
  
  #get function2 from patient with pt_id = IDs[i]
  function2 <- ds_cgm_complete_3days %>%
    filter(pt_id == IDs[i], visitnum == j, day_in_subrange %in% 1:3) %>%
    select(pt_id,trt_group,visitnum,day_in_subrange,glucose_value,device_tm_bin)

  f2.df <- as.data.frame(function2)
  
  current.df <- rbind(current.df,f2.df)
  
  }
  
}


####################################################
# add in missing time bin values/rows via complete (allows for preservation of trt_group in resulting df); called resulting new # dataframe "ex"
####################################################
ex <- ds_cgm_complete_3days %>% 
  select(pt_id,trt_group,visitnum,day_in_subrange,glucose_value,device_tm_bin) %>%
  mutate(pt_id = factor(pt_id,levels=unique(pt_id))) %>% #preserve ordering by patient id
  complete(nesting(pt_id,trt_group,visitnum,day_in_subrange), device_tm_bin = seq(1,288, 1L))

#resort by patient id, then visit number, then day within visit
ex <- ex %>% group_by(pt_id) %>% arrange(pt_id,visitnum,day_in_subrange) %>% ungroup()

#removes benign "Unknown or uninitialised column" warnings
ex <- as.data.frame(ex)

##########################################################################
#save full patient record, now with time record gaps filled in by NA values
saveRDS(ex, file = "ds_cgm_complete_3days_with_NAs.RDS")
##########################################################################


#check: all max device_tm_bin values should equal 288
out <- ex %>%
    group_by(pt_id,day_in_subrange) %>%
    summarize(max.bintm = max(device_tm_bin))

#some plotting
ex %>%
  filter(day_in_subrange == 1) %>%
  ggplot(aes(x = device_tm_bin, y = glucose_value, group =pt_id, color = pt_id)) + 
  geom_line() +
  ggtitle("pt_id = 155, visit 5, day 2: patient curve data before cubic spline interpolation")

#plot to check behavior/see how many NA values there are
ex %>%
  ggplot(aes(x = device_tm_bin, y = glucose_value, group =pt_id, color = pt_id)) + 
  geom_line() +
  ggtitle("pt_id = 155, visit 5, day 2: patient curve data before cubic spline interpolation")
ggsave("curve_data_ex_before_interp.png",device="png")


```

```{r imputestep}

###################
# IMPUTATION STEP #
###################

#interpolate missing glucose measurement values for each patient's curve data using some kind of method--use zoo::na.approx to do linear interpolation based on issues identified with cubic spline interpolation
#create new column to store imputed values
ex$glucose_imputed <- rep(0,288*length.IDs*length.days)
#update patient ID factor levels
IDs <- levels(ex$pt_id)

#do the linear interpolation and write values to ex$glucose_imputed
increment <- 1
for (i in 1:length.IDs){
  for (j in visits){
    
  #do imputation for patient i on visit j
  temp <- ex %>%
    filter(pt_id == IDs[i], visitnum == j) %>%
    #arrange(pt_id, visitnum, device_tm_bin)
    #na.approx does the linear interpolation; na.rm = FALSE preserves leading or trailing NAs. na.fill's "extend" fills in the leading or trailing NAs with the nearest non-NA value.
    mutate(glucose_imputed = zoo::na.fill(na.approx(glucose_value, na.rm = FALSE),"extend")) %>% #requires zoo package
    select(glucose_imputed)
  first <- 1+(increment-1)*length.obsns*length.days
  last <- increment*length.obsns*length.days
  #write imputed values to ex$glucose_imputed
  ex$glucose_imputed[first:last] <- temp$glucose_imputed

  increment <- increment + 1
    
  }

}
increment <- 1

#save ex object to RDS, now with NA values imputed/extended:
saveRDS(ex, file = "ds_cgm_3days_complete_with_imputed.RDS")

#save ex object to RDS, now with NA values imputed/extended:
saveRDS(ex, file = "ds_cgm_3days_sub10_with_imputed.rds")

```

```{r baselinepatient}

################################################
# GRAPHICS FOR SELECTED BASELINE PATIENT CURVE #
################################################

#baseline patient has ID = 78

#selected baseline patient curve before linear interpolation
before <- ex %>%
  filter(pt_id == IDs[57], visitnum == 0, day_in_subrange == 1) %>%
  ggplot(aes(x = as.POSIXct(timegrid), y = glucose_value, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("pt_id = 78 at randomization: baseline curve for alignment before lin. interp.") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") + 
  xlab("time of day (hr:min)") +
  ylab("glucose values")
#ggsave("./baseline_curve_data_for_alignment_before_interp.png",device="png")

#selected baseline patient curve after linear interpolation
after <- ex %>%
  filter(pt_id == IDs[57], visitnum == 0, day_in_subrange == 1) %>%
  ggplot(aes(x = as.POSIXct(timegrid), y = glucose_imputed, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("pt_id = 78 at randomization: baseline curve for alignment after lin. interp.") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") + 
  xlab("time of day (hr:min)") +
  ylab("glucose values")
#ggsave("./baseline_curve_data_for_alignment_after_interp.png",device="png")
ggsave("baseline.pt.before.after.png",arrangeGrob(before,after))

#selected baseline patient curve after linear interpolation
ex %>%
  filter(pt_id == IDs[57], visitnum == 0, day_in_subrange == 1) %>%
  ggplot(aes(x = as.POSIXct(timegrid), y = glucose_aligned, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("pt_id = 78, 0 days from initial visit: baseline curve for alignment after lin. interpolation") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") + 
  xlab("time of day (hr:min:sec)") +
  ylab("glucose values")
ggsave("./baseline_curve_data_for_alignment_after_interp.png",device="png")

```

```{r alignmentstep}

#############################
# FUNCTIONAL ALIGNMENT STEP #
#############################

#get our baseline patient data from visit 0, day 1
baseline_data <- ex %>%
  filter(pt_id == IDs[57], visitnum == 0, day_in_subrange == 1)
#save this to an RDS
saveRDS(baseline_data,file="baseline_patient_data_for_srvf_align.RDS")

#get the imputed values from our baseline reference patient data
f1.imputed <- baseline_data %>%
  select(pt_id,glucose_imputed,device_tm_bin)

#create new column in ex object for storing aligned function values
ex$glucose_aligned <- rep(0,length(ex$pt_id))

#begin alignment of remaining patient curves to baseline patient curve for this visit and day:
incr <- 1
for (j in 1:length.IDs){
  for (i in visits){
    for (k in 1:length.days){
      function2 <- ex %>%
      filter(pt_id == IDs[j], day_in_subrange == k, visitnum == i) %>%
      select(pt_id,glucose_imputed,device_tm_bin)
      #align function2 to function1 via fdasrvf package
      function2_aligned <- fdasrvf::pair_align_functions(f1.imputed$glucose_imputed, function2$glucose_imputed,f1.imputed$device_tm_bin)
      #store function2_aligned data back in ex
      first <- 1+(incr-1)*length.obsns
      last <- incr*length.obsns
      ex$glucose_aligned[first:last] <- function2_aligned$f2tilde
      incr <- incr + 1
    }
  }
}
incr <- 1

#add back in device_tm_bin_start_tm variable
ex <-  ex %>% mutate(device_tm_bin_start_tm = 
           hms::as_hms((device_tm_bin * 60 * 5) - (5 * 60)))

#save object for now
saveRDS(ex,file="ds_cgm_complete_3days_after_align.RDS")

#checking the alignment
ex %>%
  filter(pt_id == IDs[57:62],visitnum == 5, day_in_subrange == 3) %>%
  ggplot(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_aligned, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("0 days from initial visit: select curve data after lin. interpolation and srvf alignment") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  xlab("time of day (hr:min:sec)") +
  ylab("glucose values")


########################################
# GRAPHICS GENERATION FOR PRESENTATION #
########################################

############################################################################################
# SHOWING BEFORE/AFTER SRVF ALIGNMENT ALONG WITH WARPING PATHS
out10 <- ex %>%
  filter(pt_id %in% c(IDs[57:66]),visitnum == 0, day_in_subrange == 1)

#store warp functions
out10$warpfxn <- rep(0,288*length(IDs[57:66]))

#get warp functions for each of the alignments
for (i in 1:10){
  
  f2 <- out10 %>%
    filter(pt_id == IDs[56+i])
  
  warp <- fdasrvf::pair_align_functions(f1.imputed$glucose_imputed, f2$glucose_imputed,f1.imputed$device_tm_bin)
  
  first <- 1 + 288*(i-1)
  last <- 288*i
  
  out10$warpfxn[first:last] <- warp$gam
  
}

#plot for example 10 patients after imputation, before srvf alignment
pt10_1 <- ex %>%
  filter(pt_id %in% c(IDs[57:66]),visitnum == 0, day_in_subrange == 1) %>%
  ggplot(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_imputed, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("At randomization: prior to alignment of 10 patients to ref. patient curve") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  xlab("time of day (hr:min)") +
  ylab("glucose values")
#ggsave("04_10_pt_ex_curves_after_imputation_before_alignment.png",device="png")

# plot for example 10 patients after imputation and srvf alignment
pt10_2 <- ex %>%
  filter(pt_id %in% c(IDs[57:66]),visitnum == 0, day_in_subrange == 1) %>%
  ggplot(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_aligned, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("At randomization: after alignment of 10 patients to ref. patient curve") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  xlab("time of day (hr:min)") +
  ylab("glucose values")
#ggsave("04_10pt_ex_curves_after_imputation_and_alignment.png",device="png")

#plot warp functions (vs. time) used to do the srvf alignment for the 10 original patient curves
pt10_3 <- out10 %>% ggplot(aes(x = device_tm_bin/288, y = warpfxn, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("At randomization: warp paths for 10 patients after alignment") + 
  #scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  xlab("24-hr time period normalized to [0,1] interval") +
  ylab("warp")
#ggsave("04_10pt_warp_fxn_plot.png",device="png")
ggsave("04_10pt_plots_stacked.png",arrangeGrob(pt10_1,pt10_2,pt10_3),device="png", width=7,height=10)


###########################################################################################

############################################################


ex %>%
  filter(pt_id == "20",visitnum == 4, day_in_subrange == 1) %>%
  ggplot(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_imputed)) + 
  geom_line() +
  geom_line(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_aligned, color = "blue")) +
  ggtitle("At randomization: prior to alignment of pt 8 to reference patient curve") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  xlab("time of day (hr:min)") +
  ylab("glucose values")
ggsave("04_ex_curves_before_imputation_and_alignment_alt.png",device="png")

```

```{r datasubsetting}
#subset patients from visit 5 based on our new dataframe containing aligned values; patient subsetting based on original "subset10" dataframe 
ds_cgm_3days_sub10_aligned <- ex %>% filter(pt_id %in% as.character(unique(ds_cgm_sub10$pt_id)), visitnum == 5)

#save the object 
saveRDS(ds_cgm_3days_sub10_aligned,file="ds_cgm_3days_sub10_aligned.RDS")

```

```{r misc}

#work with sub10 group and check alignment

#grab a patient
f2.pt3 <- ds_cgm_3days_sub10_aligned %>% filter (pt_id == "40",visitnum == 5, day_in_subrange == 1)

out <- fdasrvf::pair_align_functions(f1.imputed$glucose_imputed,f2.pt3$glucose_imputed,time=seq(1,288,1))

plot(x=as.POSIXct(timegrid),y=f2.pt3$glucose_imputed, xlab="time",ylab="glucose values",main="patient 40, 178 days from initial visit: before and after srvf alignment",type="l")
lines(x=as.POSIXct(timegrid),y=out$f2tilde,col="red",type="l")
legend("topleft", legend = c("before alignment","after alignment"),lty = 1:1, col=c("black","red"))



ex %>%  filter(pt_id == "8",visitnum == 5, day_in_subrange == 1) %>%
  ggplot() +
  geom_line(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_imputed), color = "blue") +
  geom_line(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_aligned), color = "red") +
  ggtitle("0 days from initial visit: select curve data after lin. interpolation, before alignment") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  xlab("time of day (hr:min:sec)") +
  ylab("glucose values")

###################
#plotting progress#
###################
ex %>%
  filter(pt_id == IDs[57:62],visitnum == 0, day_in_subrange == 1) %>%
  ggplot(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_value, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("At randomization: select curve data before lin. interpolation and alignment") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  xlab("time of day (hr:min") +
  ylab("glucose values")
ggsave("04_ex_curves_before_imputation_and_alignment_alt.png",device="png")

ex %>%
  filter(pt_id == IDs[57:62],visitnum == 0, day_in_subrange == 1) %>%
  ggplot(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_imputed, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("At randomization: select curve data after lin. interpolation, before alignment") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  xlab("time of day (hr:min)") +
  ylab("glucose values")
ggsave("04_ex_curves_after_imputation_before_alignment_alt.png",device="png")

ex %>%
  filter(pt_id == IDs[57:62],visitnum == 0, day_in_subrange == 1) %>%
  ggplot(aes(x = as.POSIXct(device_tm_bin_start_tm), y = glucose_aligned, color = pt_id, group = pt_id)) + 
  geom_line() +
  ggtitle("At randomization: select curve data after lin. interpolation and srvf alignment") + 
  scale_x_datetime(date_labels = "%H:%M", date_breaks = "2 hours") +
  xlab("time of day (hr:min)") +
  ylab("glucose values")
ggsave("04_ex_curves_after_imputation_and_alignment_alt.png",device="png")

```
